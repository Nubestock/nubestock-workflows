name: Deploy Azure Functions - Reusable Workflow

on:
  workflow_call:
    inputs:
      environment:
        description: "Environment a desplegar (NUBESTOCK_DEV, NUBESTOCK_UAT, NUBESTOCK_PRD)"
        required: true
        type: string
      node_version:
        description: "Versi√≥n de Node.js"
        required: false
        type: string
        default: "22"
    secrets:
      AZ_CLIENT_ID:
        required: true
      AZ_CLIENT_SECRET:
        required: true
      AZ_TENANT_ID:
        required: true
      AZ_SUBSCRIPTION_ID:
        required: true
      AZ_FUNCTION_APP_NAME:
        required: true
      AZ_RESOURCE_GROUP:
        required: true
      FUNCTIONS_WORKER_RUNTIME:
        required: true
      FUNCTIONS_EXTENSION_VERSION:
        required: true
      DATABASE_HOSTNAME:
        required: true
      DATABASE_PORT:
        required: true
      DATABASE_NAME:
        required: true
      DATABASE_USERNAME:
        required: true
      DATABASE_PASSWORD:
        required: true
      DB_SSL:
        required: true
      NODE_ENV:
        required: true
      LOG_LEVEL:
        required: true
      LOG_FORMAT:
        required: true
      JWT_SECRET:
        required: true
      EMAIL_ENABLED:
        required: true
      AZURE_COMMUNICATION_CONNECTION_STRING:
        required: true
      EMAIL_FROM:
        required: true
      EMAIL_FROM_NAME:
        required: true
      FRONTEND_URL:
        required: true
      RESET_PASSWORD_PATH:
        required: true
      PASSWORD_RESET_TOKEN_EXPIRY:
        required: true
      BOOTSTRAP_KEY:
        required: true
      AzureWebJobsStorage:
        required: true
      NOTIFICATION_HUB_ENABLED:
        required: true
      NOTIFICATION_HUB_CONNECTION_STRING:
        required: true
      NOTIFICATION_HUB_NAME:
        required: true
      NOTIFICATION_HUB_INTERNAL_KEY:
        required: true

env:
  AZURE_FUNCTIONAPP_PACKAGE_PATH: backend-deploy
  NODE_VERSION: ${{ inputs.node_version }}

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - name: Checkout Backend Repository
        uses: actions/checkout@v4
        with:
          repository: ${{ github.repository }}
          path: backend

      - name: Setup Node.js ${{ env.NODE_VERSION }}
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install dependencies
        working-directory: ./backend
        run: npm ci

      - name: Build TypeScript
        working-directory: ./backend
        run: npm run build

      - name: Verify build output
        working-directory: ./backend
        run: |
          echo "üîç Verificando estructura de archivos compilados..."
          if [ ! -d "dist" ]; then
            echo "‚ùå ERROR: La carpeta 'dist' no existe despu√©s del build"
            exit 1
          fi
          echo "‚úÖ Carpeta 'dist' encontrada"
          
          # Verificar que existen al menos algunos archivos compilados comunes
          if [ ! -f "dist/healthcheck/index.js" ] && [ ! -f "dist/auth/index.js" ] && [ ! -f "dist/users/index.js" ]; then
            echo "‚ö†Ô∏è  ADVERTENCIA: No se encontraron archivos compilados comunes en dist/"
            echo "üìÅ Contenido de dist/:"
            ls -la dist/ || echo "dist/ est√° vac√≠a"
          else
            echo "‚úÖ Archivos compilados encontrados en dist/"
            echo "üìÅ Estructura de dist/:"
            find dist -name "*.js" -type f | head -10
          fi

      - name: Zip artifact
        working-directory: ./backend
        run: zip -r ../release.zip ./*

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: node-app
          path: release.zip

  deploy:
    runs-on: ubuntu-latest
    needs: build
    permissions:
      contents: read
    environment:
      name: ${{ inputs.environment }}
    env:
      FUNCTIONS_EXTENSION_VERSION: ${{ secrets.FUNCTIONS_EXTENSION_VERSION }}
      DATABASE_HOSTNAME: ${{ secrets.DATABASE_HOSTNAME }}
      DATABASE_PORT: ${{ secrets.DATABASE_PORT }}
      DATABASE_NAME: ${{ secrets.DATABASE_NAME }}
      DATABASE_USERNAME: ${{ secrets.DATABASE_USERNAME }}
      DATABASE_PASSWORD: ${{ secrets.DATABASE_PASSWORD }}
      DB_SSL: ${{ secrets.DB_SSL }}
      NODE_ENV: ${{ secrets.NODE_ENV }}
      LOG_LEVEL: ${{ secrets.LOG_LEVEL }}
      LOG_FORMAT: ${{ secrets.LOG_FORMAT }}
      JWT_SECRET: ${{ secrets.JWT_SECRET }}
      EMAIL_ENABLED: ${{ secrets.EMAIL_ENABLED }}
      AZURE_COMMUNICATION_CONNECTION_STRING: ${{ secrets.AZURE_COMMUNICATION_CONNECTION_STRING }}
      EMAIL_FROM: ${{ secrets.EMAIL_FROM }}
      EMAIL_FROM_NAME: ${{ secrets.EMAIL_FROM_NAME }}
      FRONTEND_URL: ${{ secrets.FRONTEND_URL }}
      RESET_PASSWORD_PATH: ${{ secrets.RESET_PASSWORD_PATH }}
      PASSWORD_RESET_TOKEN_EXPIRY: ${{ secrets.PASSWORD_RESET_TOKEN_EXPIRY }}
      BOOTSTRAP_KEY: ${{ secrets.BOOTSTRAP_KEY }}
      AzureWebJobsStorage: ${{ secrets.AzureWebJobsStorage }}
      NOTIFICATION_HUB_ENABLED: ${{ secrets.NOTIFICATION_HUB_ENABLED }}
      NOTIFICATION_HUB_CONNECTION_STRING: ${{ secrets.NOTIFICATION_HUB_CONNECTION_STRING }}
      NOTIFICATION_HUB_NAME: ${{ secrets.NOTIFICATION_HUB_NAME }}
      NOTIFICATION_HUB_INTERNAL_KEY: ${{ secrets.NOTIFICATION_HUB_INTERNAL_KEY }}

    steps:
      - name: Checkout Backend Repository
        uses: actions/checkout@v4
        with:
          repository: ${{ github.repository }}
          path: backend

      - name: Download artifact
        uses: actions/download-artifact@v4
        with:
          name: node-app

      - name: Unzip artifact
        run: unzip release.zip -d backend-deploy

      - name: Login to Azure
        shell: bash
        run: |
          az login --service-principal \
            --username "${{ secrets.AZ_CLIENT_ID }}" \
            --password "${{ secrets.AZ_CLIENT_SECRET }}" \
            --tenant "${{ secrets.AZ_TENANT_ID }}" \
            --output none

          az account set --subscription "${{ secrets.AZ_SUBSCRIPTION_ID }}"

      - name: Validar existencia del Function App
        shell: bash
        run: |
          echo "üîç Validando existencia del Function App..."

          FUNCTION_APP_NAME="${{ secrets.AZ_FUNCTION_APP_NAME }}"
          RESOURCE_GROUP="${{ secrets.AZ_RESOURCE_GROUP }}"

          if az functionapp show \
            --name "$FUNCTION_APP_NAME" \
            --resource-group "$RESOURCE_GROUP" \
            &>/dev/null; then
            echo "‚úÖ Function App encontrado. Continuando despliegue."
          else
            echo ""
            echo "‚ùå ERROR CR√çTICO"
            echo "---------------------------------------------"
            echo "‚ùå El Function App '$FUNCTION_APP_NAME' NO existe"
            echo "‚ùå Resource Group: $RESOURCE_GROUP"
            echo ""
            echo "üëâ Este workflow NO crea infraestructura"
            echo "üëâ Crea el Function App previamente (ARM/Bicep)"
            echo "‚õî Abortando despliegue"
            exit 1
          fi

      - name: Sincronizar Application Settings
        shell: bash
        run: |
          echo "üîÑ Sincronizando variables din√°micas..."

          REQUIRED_VARS=(
            "FUNCTIONS_EXTENSION_VERSION"
            "DATABASE_HOSTNAME"
            "DATABASE_PORT"
            "DATABASE_NAME"
            "DATABASE_USERNAME"
            "DATABASE_PASSWORD"
            "DB_SSL"
            "NODE_ENV"
            "LOG_LEVEL"
            "LOG_FORMAT"
            "JWT_SECRET"
            "EMAIL_ENABLED"
            "AZURE_COMMUNICATION_CONNECTION_STRING"
            "EMAIL_FROM"
            "EMAIL_FROM_NAME"
            "FRONTEND_URL"
            "RESET_PASSWORD_PATH"
            "PASSWORD_RESET_TOKEN_EXPIRY"
            "BOOTSTRAP_KEY"
            "AzureWebJobsStorage"
            "NOTIFICATION_HUB_ENABLED"
            "NOTIFICATION_HUB_CONNECTION_STRING"
            "NOTIFICATION_HUB_NAME"
            "NOTIFICATION_HUB_INTERNAL_KEY"
          )

          MISSING=()
          for VAR in "${REQUIRED_VARS[@]}"; do
            if [ -z "${!VAR}" ]; then
              MISSING+=("$VAR")
            fi
          done

          if [ ${#MISSING[@]} -ne 0 ]; then
            echo "‚ùå Faltan variables requeridas:"
            for VAR in "${MISSING[@]}"; do
              echo " - $VAR"
            done
            exit 1
          fi

          az functionapp config appsettings set \
            --name "${{ secrets.AZ_FUNCTION_APP_NAME }}" \
            --resource-group "${{ secrets.AZ_RESOURCE_GROUP }}" \
            --settings \
              "FUNCTIONS_EXTENSION_VERSION=${FUNCTIONS_EXTENSION_VERSION}" \
              "DATABASE_HOSTNAME=${DATABASE_HOSTNAME}" \
              "DATABASE_PORT=${DATABASE_PORT}" \
              "DATABASE_NAME=${DATABASE_NAME}" \
              "DATABASE_USERNAME=${DATABASE_USERNAME}" \
              "DATABASE_PASSWORD=${DATABASE_PASSWORD}" \
              "DB_SSL=${DB_SSL}" \
              "NODE_ENV=${NODE_ENV}" \
              "LOG_LEVEL=${LOG_LEVEL}" \
              "LOG_FORMAT=${LOG_FORMAT}" \
              "JWT_SECRET=${JWT_SECRET}" \
              "EMAIL_ENABLED=${EMAIL_ENABLED}" \
              "AZURE_COMMUNICATION_CONNECTION_STRING=${AZURE_COMMUNICATION_CONNECTION_STRING}" \
              "EMAIL_FROM=${EMAIL_FROM}" \
              "EMAIL_FROM_NAME=${EMAIL_FROM_NAME}" \
              "FRONTEND_URL=${FRONTEND_URL}" \
              "RESET_PASSWORD_PATH=${RESET_PASSWORD_PATH}" \
              "PASSWORD_RESET_TOKEN_EXPIRY=${PASSWORD_RESET_TOKEN_EXPIRY}" \
              "BOOTSTRAP_KEY=${BOOTSTRAP_KEY}" \
              "AzureWebJobsStorage=${AzureWebJobsStorage}" \
              "NOTIFICATION_HUB_ENABLED=${NOTIFICATION_HUB_ENABLED}" \
              "NOTIFICATION_HUB_CONNECTION_STRING=${NOTIFICATION_HUB_CONNECTION_STRING}" \
              "NOTIFICATION_HUB_NAME=${NOTIFICATION_HUB_NAME}" \
              "NOTIFICATION_HUB_INTERNAL_KEY=${NOTIFICATION_HUB_INTERNAL_KEY}"

      - name: Deploy Azure Function
        uses: Azure/functions-action@v1
        with:
          app-name: ${{ secrets.AZ_FUNCTION_APP_NAME }}
          slot-name: Production
          package: ${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}

      - name: Wait for function to be ready
        shell: bash
        run: |
          echo "‚è≥ Esperando 15 segundos para que la funci√≥n se active..."
          sleep 15

      - name: Validate function deployment and environment variables
        shell: bash
        run: |
          echo "üîç Validando despliegue y variables de entorno..."
          
          # Instalar jq si no est√° disponible (normalmente ya est√° en GitHub Actions)
          if ! command -v jq &> /dev/null; then
            echo "üì¶ Instalando jq para parsing JSON..."
            sudo apt-get update && sudo apt-get install -y jq
          fi
          
          FUNCTION_APP_NAME="${{ secrets.AZ_FUNCTION_APP_NAME }}"
          HEALTHCHECK_URL="https://${FUNCTION_APP_NAME}.azurewebsites.net/api/healthcheck"
          
          echo "üìç URL del healthcheck: ${HEALTHCHECK_URL}"
          
          # Realizar petici√≥n con reintentos (usar archivo temporal para no mezclar salida de curl con errores)
          MAX_RETRIES=3
          RETRY_DELAY=10
          HTTP_STATUS=""
          RESPONSE_BODY=""
          CURL_OK=false
          BODY_FILE=$(mktemp)
          trap "rm -f '$BODY_FILE'" EXIT
          
          for i in $(seq 1 $MAX_RETRIES); do
            echo "üîÑ Intento $i de $MAX_RETRIES..."
            
            CURL_STDERR=$(mktemp)
            HTTP_STATUS=$(curl -s -w "%{http_code}" -o "$BODY_FILE" -X GET "${HEALTHCHECK_URL}" \
              -H "Content-Type: application/json" \
              --max-time 30 \
              --retry 2 \
              --retry-delay 5 \
              --connect-timeout 15 \
              2>"$CURL_STDERR") || true
            CURL_EXIT=$?
            RESPONSE_BODY=$(cat "$BODY_FILE" 2>/dev/null || echo "")
            
            # Si curl fall√≥ por conexi√≥n, puede devolver vac√≠o o 000
            if [ -z "$HTTP_STATUS" ] || [ "$HTTP_STATUS" = "000" ]; then
              echo "üìä No se pudo conectar (curl exit: ${CURL_EXIT})"
              [ -s "$CURL_STDERR" ] && echo "   Detalle: $(cat "$CURL_STDERR")"
              HTTP_STATUS="000"
            else
              echo "üìä C√≥digo HTTP: ${HTTP_STATUS}"
            fi
            rm -f "$CURL_STDERR"
            
            # Solo d√≠gitos de 3 cifras = c√≥digo HTTP v√°lido
            if echo "$HTTP_STATUS" | grep -qE '^[0-9]{3}$'; then
              if [ "$HTTP_STATUS" = "200" ] || [ "$HTTP_STATUS" = "503" ]; then
                echo "‚úÖ Funci√≥n responde (HTTP ${HTTP_STATUS})"
                CURL_OK=true
                break
              fi
            fi
            
            echo "‚ö†Ô∏è  No se pudo validar la funci√≥n (HTTP ${HTTP_STATUS})"
            if [ $i -lt $MAX_RETRIES ]; then
              echo "‚è≥ Esperando ${RETRY_DELAY} segundos antes del siguiente intento..."
              sleep $RETRY_DELAY
            fi
          done
          
          # Validar respuesta HTTP
          if [ "$CURL_OK" != "true" ]; then
            echo ""
            echo "‚ùå ERROR CR√çTICO"
            echo "---------------------------------------------"
            echo "‚ùå No se pudo conectar al healthcheck de la funci√≥n."
            echo "‚ùå URL: ${HEALTHCHECK_URL}"
            echo ""
            echo "üí° Posibles causas:"
            echo "  - La Function App no es accesible desde internet (red/firewall)"
            echo "  - La funci√≥n tarda m√°s en arrancar (aumentar la espera previa)"
            echo "  - La URL del Function App es incorrecta"
            echo ""
            if [ -n "$RESPONSE_BODY" ]; then
              echo "üìÑ Respuesta recibida:"
              echo "${RESPONSE_BODY}"
            fi
            exit 1
          fi
          
          # Validar que la respuesta es JSON v√°lido
          echo ""
          echo "üìã Analizando respuesta del healthcheck..."
          if ! echo "${RESPONSE_BODY}" | jq empty 2>/dev/null; then
            echo "‚ö†Ô∏è  ADVERTENCIA: La respuesta no es JSON v√°lido"
            echo "üìÑ Respuesta completa:"
            echo "${RESPONSE_BODY}"
            echo ""
            echo "‚úÖ La funci√≥n responde, pero no se pudo validar el contenido"
            exit 0
          fi
          
          # Mostrar JSON formateado
          echo "${RESPONSE_BODY}" | jq '.'
          
          # Extraer informaci√≥n del healthcheck
          STATUS=$(echo "${RESPONSE_BODY}" | jq -r '.status // "unknown"')
          TIMESTAMP=$(echo "${RESPONSE_BODY}" | jq -r '.timestamp // "unknown"')
          RESPONSE_TIME=$(echo "${RESPONSE_BODY}" | jq -r '.responseTime // "unknown"')
          
          echo ""
          echo "üìä Estado del Healthcheck:"
          echo "  Status: ${STATUS}"
          echo "  Timestamp: ${TIMESTAMP}"
          echo "  Response Time: ${RESPONSE_TIME}"
          echo ""
          
          # Validar checks individuales
          API_STATUS=$(echo "${RESPONSE_BODY}" | jq -r '.checks.api.status // "unknown"')
          DB_STATUS=$(echo "${RESPONSE_BODY}" | jq -r '.checks.database.status // "unknown"')
          ENV_STATUS=$(echo "${RESPONSE_BODY}" | jq -r '.checks.environment.status // "unknown"')
          
          echo "üîç Validaci√≥n de Componentes:"
          echo "  API: ${API_STATUS}"
          echo "  Database: ${DB_STATUS}"
          echo "  Environment Variables: ${ENV_STATUS}"
          echo ""
          
          # Validar variables de entorno cr√≠ticas
          ENV_MESSAGE=$(echo "${RESPONSE_BODY}" | jq -r '.checks.environment.message // ""')
          
          if [ "$ENV_STATUS" = "unhealthy" ]; then
            echo "‚ùå ERROR: Variables de entorno cr√≠ticas faltantes o incorrectas"
            echo "üìù Mensaje: ${ENV_MESSAGE}"
            echo ""
            echo "üîç Verificando variables esperadas en el workflow..."
            echo "  - DATABASE_HOSTNAME: ${DATABASE_HOSTNAME:+‚úÖ Configurada}"
            echo "  - DATABASE_NAME: ${DATABASE_NAME:+‚úÖ Configurada}"
            echo "  - JWT_SECRET: ${JWT_SECRET:+‚úÖ Configurada}"
            echo ""
            echo "‚ö†Ô∏è  Las variables est√°n configuradas en el workflow pero no en Azure Function App"
            exit 1
          fi
          
          if [ "$STATUS" = "unhealthy" ]; then
            echo "‚ùå ERROR: El sistema est√° marcado como 'unhealthy'"
            echo "üìù Detalles de los checks:"
            echo "${RESPONSE_BODY}" | jq '.checks'
            exit 1
          fi
          
          if [ "$STATUS" = "degraded" ]; then
            echo "‚ö†Ô∏è  ADVERTENCIA: El sistema est√° 'degraded' pero funcional"
            echo "üìù Detalles de los checks:"
            echo "${RESPONSE_BODY}" | jq '.checks'
            echo ""
            echo "‚úÖ Despliegue completado con advertencias"
          else
            echo "‚úÖ Sistema saludable - Todas las validaciones pasaron"
            echo ""
            echo "‚úÖ Despliegue validado exitosamente"
            echo "‚úÖ Variables de entorno configuradas correctamente"
            echo "‚úÖ Funci√≥n operativa y respondiendo"
          fi